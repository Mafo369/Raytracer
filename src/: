#include "intersection.hpp"

Ray transform(Ray* ray, glm::mat4 matrix){
  Ray transformedRay;
  vec4 origin = matrix * vec4(ray->orig, 1);
  vec4 direction = matrix * vec4(ray->dir, 0);
  rayInit(&transformedRay, vec3(origin.x, origin.y, origin.z), vec3(direction.x, direction.y, direction.z), ray->tmin, ray->tmax, ray->depth); 
  return transformedRay;
}

bool intersectPlane(Ray *ray, Intersection *intersection, Object *obj)
{

  //! \todo : compute intersection of the ray and the plane object

  vec3 n = obj->geom.plane.normal;
  float dn = dot(ray->dir, n);

  if (dn == 0.0)
  {
    //Pas des solutions
    return false;
  }
  else
  {
    float t = -(dot(ray->orig, n) + obj->geom.plane.dist) / dn;
    if (t >= ray->tmin && t <= ray->tmax)
    {
      intersection->position = ray->orig + (t * ray->dir);
      intersection->mat = &(obj->mat);
      intersection->normal = n;
      intersection->u = abs(fmod(intersection->position.x, 1.0f));
      intersection->v = abs(fmod(intersection->position.z, 1.0f));
      //if(intersection->position.x < 0 && intersection->position.z > 0){
      //  intersection->u = 1+fmod(intersection->position.x / 6, 1.0f);
      //  intersection->v = abs(fmod(intersection->position.z / 6, 1.0f));
      //}
      //else if(intersection->position.x < 0 && intersection->position.z < 0){
      //  intersection->u = abs(fmod(intersection->position.x / 6, 1.0f));
      //  intersection->v = abs(fmod(intersection->position.z / 6, 1.0f));
      //}
      //else if(intersection->position.x > 0 && intersection->position.z < 0){
      //  intersection->u = abs(fmod(intersection->position.x / 6, 1.0f));
      //  intersection->v = 1+fmod(intersection->position.z / 6, 1.0f);
      //}
      //else
      //{
      //  intersection->u = 1+fmod(intersection->position.x / 6, 1.0f);
      //  intersection->v = abs(fmod(intersection->position.z / 6, 1.0f));
      //}
      ray->tmax = t;
      return true;
    }
  }

  return false;
}

bool intersectSphere(Ray *ray, Intersection *intersection, Object *obj)
{

  //! \todo : compute intersection of the ray and the sphere object
  
  Ray transformedRay = transform(ray, obj->invTransform);

  vec3 oc = transformedRay.orig - point3(0,0,0);
  float a = dot(transformedRay.dir, transformedRay.dir);
  float b = 2.f * dot(transformedRay.dir, oc);
  float c = dot(oc, oc) - 1;

  float delta = b * b - 4 * a * c;

  if (delta == 0)
  {
    //Une solution
    float t = -b / (2*a);
    if (t >= ray->tmin && t <= ray->tmax)
    {
      intersection->position = ray->orig + (t * ray->dir);
      intersection->mat = &(obj->mat);
    vec3 objectPoint = obj->invTransform * vec4(intersection->position, 1);
    vec3 objectNormal = objectPoint - vec3(0,0,0);
    glm::mat4 normalMatrix = glm::transpose(obj->invTransform);
    vec3 normal = normalMatrix * vec4(objectNormal, 1);
    intersection->isOutside = dot(transformedRay.dir, objectNormal) < 0;
    intersection->transform = obj->transform;
    intersection->normal = normalize(normal);

      float pi = M_PI;
      auto theta = acos(-normal.y);
      auto phi = atan2(-normal.z, normal.x) + pi;

      intersection->u = phi / (2*pi);
      intersection->v = theta / pi;

      ray->tmax = t;
      return true;
    }
  }
  else if (delta > 0)
  {

    //Deux solutions
    float t1 = (-b + sqrtf(delta)) / (2*a);
    float t2 = (-b - sqrtf(delta)) / (2*a);
    float t;
    if (t1 >= transformedRay.tmin && t1 <= transformedRay.tmax && t2 >= transformedRay.tmin && t2 <= transformedRay.tmax)
    {
      t = std::min(t1, t2);
    }
    else if (t1 >= transformedRay.tmin && t1 <= transformedRay.tmax)
    {
      t = t1;
    }
    else if (t2 >= transformedRay.tmin && t2 <= transformedRay.tmax)
    {
      t = t2;
    }
    else
    {
      return false;
    }
    intersection->position = ray->orig + (t * ray->dir);
    intersection->mat = &(obj->mat);
    vec3 objectPoint = obj->invTransform * vec4(intersection->position, 1);
    vec3 objectNormal = objectPoint - vec3(0,0,0);
    glm::mat4 normalMatrix = glm::transpose(obj->invTransform);
    vec3 normal = normalMatrix * vec4(objectNormal, 1);
    intersection->isOutside = dot(transformedRay.dir, objectNormal) < 0;
    intersection->transform = obj->transform;
    intersection->normal = normalize(normal);

    float pi = M_PI;
    auto theta = acos(-normal.y);
    auto phi = atan2(-normal.z, normal.x) + pi;
    intersection->u = phi / (2*pi);
    intersection->v = theta / pi;


    ray->tmax = t;
    return true;
  }
  return false;
}

//bool intersectSphere(Ray *ray, Intersection *intersection, Object *obj)
//{
//
//  //! \todo : compute intersection of the ray and the sphere object
//
//  vec3 oc = ray->orig - obj->geom.sphere.center;
//  float b = 2 * (dot(ray->dir, oc));
//  float c = dot(oc, oc) - (obj->geom.sphere.radius * obj->geom.sphere.radius);
//
//  float delta = b * b - 4 * c;
//
//  if (delta == 0)
//  {
//    //Une solution
//    float t = -b / 2;
//    if (t >= ray->tmin && t <= ray->tmax)
//    {
//      intersection->position = ray->orig + (t * ray->dir);
//      intersection->mat = &(obj->mat);
//      vec3 normal = normalize(intersection->position - obj->geom.sphere.center);
//      intersection->isOutside = dot(ray->dir, normal) < 0;
//      //intersection->normal = intersection->isOutside ? normal : -normal;
//      intersection->normal = normal;
//
//      float pi = M_PI;
//      auto theta = acos(-normal.y);
//      auto phi = atan2(-normal.z, normal.x) + pi;
//
//      intersection->u = phi / (2*pi);
//      intersection->v = theta / pi;
//
//      ray->tmax = t;
//      return true;
//    }
//  }
//  else if (delta > 0)
//  {
//    //Deux solutions
//    float t1 = (-b + sqrtf(delta)) / 2;
//    float t2 = (-b - sqrtf(delta)) / 2;
//    float t;
//    if (t1 >= ray->tmin && t1 <= ray->tmax && t2 >= ray->tmin && t2 <= ray->tmax)
//    {
//      t = std::min(t1, t2);
//    }
//    else if (t1 >= ray->tmin && t1 <= ray->tmax)
//    {
//      t = t1;
//    }
//    else if (t2 >= ray->tmin && t2 <= ray->tmax)
//    {
//      t = t2;
//    }
//    else
//    {
//      return false;
//    }
//    intersection->position = ray->orig + (t * ray->dir);
//    intersection->mat = &(obj->mat);
//    vec3 normal = normalize(intersection->position - obj->geom.sphere.center);
//    intersection->isOutside = dot(ray->dir, normal) < 0;
//    //intersection->normal = intersection->isOutside ? normal : -normal;
//    intersection->normal = normal;
//    float pi = M_PI;
//    auto theta = acos(-normal.y);
//    auto phi = atan2(-normal.z, normal.x) + pi;
//
//    intersection->u = phi / (2*pi);
//    intersection->v = theta / pi;
//
//
//    ray->tmax = t;
//    return true;
//  }
//  else
//  {
//    //Pas de solutions -> pas d'intersection
//  }
//  return false;
//}

//Moller-Trumbore Ray Triangle Intersection
bool intersectTriangle(Ray *ray, Intersection *intersection, Object *obj)
{
  vec3 v1v2 = obj->geom.triangle.p2 - obj->geom.triangle.p1;
  vec3 v1v3 = obj->geom.triangle.p3 - obj->geom.triangle.p1;

  vec3 cross_rayDir_v1v3 = cross(ray->dir, v1v3);

  float det = dot(v1v2, cross_rayDir_v1v3);

  if (det > -acne_eps && det < acne_eps)
    return false;

  float inv_det = 1.f / det;

  vec3 o_minus_p1 = ray->orig - obj->geom.triangle.p1;

  float u = dot(o_minus_p1, cross_rayDir_v1v3) * inv_det;

  if (u < 0.f || u > 1.f)
    return false;

  vec3 cross_oMinusp1_v1v2 = cross(o_minus_p1, v1v2);

  float v = dot(ray->dir, cross_oMinusp1_v1v2) * inv_det;

  if (v < 0.f || u + v > 1.f)
    return false;

  float t = dot(v1v3, cross_oMinusp1_v1v2) * inv_det;

  if (t >= ray->tmin && t <= ray->tmax)
  {
    intersection->position = ray->orig + (t * ray->dir);
    intersection->mat = &(obj->mat);
    intersection->isOutside = dot(ray->dir, obj->geom.triangle.normal) < 0;
    //intersection->normal = intersection->isOutside ? obj->geom.triangle.normal : -obj->geom.triangle.normal;
    auto uv = obj->geom.triangle.tex[1] * u + obj->geom.triangle.tex[2] * v + obj->geom.triangle.tex[0] * (1.f - u - v);
    intersection->u = uv.x;
    intersection->v = uv.y;
    vec3 normal = obj->geom.triangle.n2 * u + obj->geom.triangle.n3 * v + obj->geom.triangle.n1 * (1.f - u - v);

    intersection->normal = normal;
    ray->tmax = t;
    return true;
  }
  return false;
}

bool intersectScene(const Scene *scene, Ray *ray, Intersection *intersection)
{
  bool hasIntersection = false;
  size_t objectCount = scene->objects.size();

  //!\todo loop on each object of the scene to compute intersection

  float dist;

  for (size_t i = 0; i < objectCount; i++)
  {
    Intersection *temp = (Intersection *)malloc(sizeof(Intersection));
    if (scene->objects[i]->geom.type == PLANE)
    {
      if (intersectPlane(ray, temp, scene->objects[i]))
      {
        float temp_dist = ray->tmax;
        if (hasIntersection)
        {
          if (temp_dist < dist)
          {
            dist = temp_dist;
            *intersection = *temp;
          }
        }
        else
        {
          hasIntersection = true;
          *intersection = *temp;
          dist = temp_dist;
        }
      }
    }
    else if (scene->objects[i]->geom.type == SPHERE)
    {
      if (intersectSphere(ray, temp, scene->objects[i]))
      {
        float temp_dist = ray->tmax;
        if (hasIntersection)
        {
          if (temp_dist < dist)
          {
            dist = temp_dist;
            *intersection = *temp;
          }
        }
        else
        {
          hasIntersection = true;
          *intersection = *temp;
          dist = temp_dist;
        }
      }
    }
    else if (scene->objects[i]->geom.type == TRIANGLE)
    {
      if (intersectTriangle(ray, temp, scene->objects[i]))
      {
        float temp_dist = ray->tmax;
        if (hasIntersection)
        {
          if (temp_dist < dist)
          {
            dist = temp_dist;
            *intersection = *temp;
          }
        }
        else
        {
          hasIntersection = true;
          *intersection = *temp;
          dist = temp_dist;
        }
      }
    }
    free(temp);
  }
  return hasIntersection;
}

void check_axis(float origin, float direction, float min, float max, float& tmin, float& tmax){
  float tmin_numerator = (min - origin);
  float tmax_numerator = (max - origin);

  if(abs(direction) >= acne_eps){
    tmin = tmin_numerator / direction;
    tmax = tmax_numerator / direction;
  }
  else
  {
    tmin = tmin_numerator * INFINITY;
    tmax = tmax_numerator * INFINITY;
  }

  if(tmin > tmax) std::swap(tmin, tmax);
}

template <typename T> int sgn(T val) {
    return (T(0) < val) - (val < T(0));
}

vec3 computeCubeNormal(vec3 position, vec3 min, vec3 max){
    auto center = (max + min) * 0.5f;
    auto normal = vec3(position.x - center.x, position.y - center.y, position.z - center.z);
    auto absNormal = abs(normal);

    auto maxc = std::max(std::max(absNormal.x, absNormal.y), absNormal.z);
    if(maxc == absNormal.x){
      return normalize(vec3(normal.x, 0, 0));
    }
    else if(maxc == absNormal.y){
      return normalize(vec3(0, normal.y, 0));
    }
    return normalize(vec3(0, 0, normal.z)); 
}

enum Side {RIGHT=0, LEFT, UP, DOWN, FRONT, BACK};

Side faceFromPoint(point3 point){
  point3 absPoint = abs(point);
  float coord = std::max(std::max(absPoint.x, absPoint.y), absPoint.z);
  if(coord == point.x) return RIGHT;
  if(coord == -point.x) return LEFT;
  if(coord == point.y) return UP;
  if(coord == -point.y) return DOWN;
  if(coord == point.z) return FRONT;
  return BACK;
}

vec2 cube_uv_front(point3 point, vec3 max){
  float u = abs(fmod(point.x + max.x, 2.0f) / 2.0f);
  float v = abs(fmod(point.y + max.y, 2.0f) / 2.0f);
  return vec2(u, v);
}

vec2 cube_uv_back(point3 point, vec3 max){
  float u = abs(fmod(max.x - point.x, 2.0f) / 2.0f);
  float v = abs(fmod(point.y + max.y, 2.0f) / 2.0f);
  return vec2(u, v);
}

vec2 cube_uv_left(point3 point, vec3 max){
  float u = abs(fmod(point.z + max.z, 2.0f) / 2.0f);
  float v = abs(fmod(point.y + max.y, 2.0f) / 2.0f);
  return vec2(u, v);
}

vec2 cube_uv_right(point3 point, vec3 max){
  float u = abs(fmod(max.z - point.z, 2.0f) / 2.0f);
  float v = abs(fmod(point.y + max.y, 2.0f) / 2.0f);
  return vec2(u, v);
}

vec2 cube_uv_up(point3 point, vec3 max, vec3 min){
  float u = abs(fmod(min.x - point.x, 2.0f) / 2.0f);
  float v = abs(fmod(max.z - point.z, 2.0f) / 2.0f);
  return vec2(u, v);
}

vec2 cube_uv_down(point3 point, vec3 max, vec3 min){
  float u = abs(fmod(min.x - point.x, 2.0f) / 2.0f);
  float v = abs(fmod(point.z + max.z, 2.0f) / 2.0f);
  return vec2(u, v);
}

bool intersectCube(Ray* ray, Intersection* intersection, Object* obj){
    float xtmin, xtmax;
    check_axis(ray->orig.x, ray->dir.x, obj->geom.cube.min.x, obj->geom.cube.max.x, xtmin, xtmax);
    float ytmin, ytmax;
    check_axis(ray->orig.y, ray->dir.y, obj->geom.cube.min.y, obj->geom.cube.max.y, ytmin, ytmax);
    float ztmin, ztmax;
    check_axis(ray->orig.z, ray->dir.z, obj->geom.cube.min.z, obj->geom.cube.max.z, ztmin, ztmax);

    float tmin = std::max(std::max(xtmin, ytmin), ztmin);
    float tmax = std::min(std::min(xtmax, ytmax), ztmax);

    if(tmin > tmax || tmin < ray->tmin || tmin > ray->tmax )
      return false;

    intersection->position = ray->orig + (tmin * ray->dir);
    intersection->mat = &(obj->mat);
    intersection->normal = computeCubeNormal(intersection->position, obj->geom.cube.min, obj->geom.cube.max);
    intersection->isOutside = dot(ray->dir, intersection->normal) < 0;

    vec2 uv;
    int face;
    vec3 absMax = glm::max(glm::abs(obj->geom.cube.max), glm::abs(obj->geom.cube.min));
    vec3 absMin = (absMax == glm::abs(obj->geom.cube.max)) ? glm::abs(obj->geom.cube.min) : glm::abs(obj->geom.cube.max);
    if(intersection->normal.x < 0){
      uv = cube_uv_left(intersection->position, absMax);
      face = 0;
    }
    else if(intersection->normal.x > 0){
      uv = cube_uv_right(intersection->position, absMax);
      face = 1;
    }
    else if(intersection->normal.z > 0) {
      uv = cube_uv_front(intersection->position, absMax);
      face = 2;
    }
    else if(intersection->normal.z < 0){
      uv = cube_uv_back(intersection->position, absMax);
      face = 3;
    }
    else if(intersection->normal.y > 0) {
      uv = cube_uv_up(intersection->position, absMax, absMin);
      face = 4;
    }
    else{
      uv = cube_uv_down(intersection->position, absMax, absMin);
      face = 5;
    }
    intersection->u = uv.x;
    intersection->v = uv.y;
    intersection->face = face;


    ray->tmax = tmin;
    return true;
}
